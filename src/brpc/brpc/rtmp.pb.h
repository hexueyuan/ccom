// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: brpc/rtmp.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_brpc_2frtmp_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_brpc_2frtmp_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_brpc_2frtmp_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_brpc_2frtmp_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_brpc_2frtmp_2eproto;
namespace brpc {
class RtmpConnectRequest;
struct RtmpConnectRequestDefaultTypeInternal;
extern RtmpConnectRequestDefaultTypeInternal _RtmpConnectRequest_default_instance_;
class RtmpConnectResponse;
struct RtmpConnectResponseDefaultTypeInternal;
extern RtmpConnectResponseDefaultTypeInternal _RtmpConnectResponse_default_instance_;
class RtmpEmptyObject;
struct RtmpEmptyObjectDefaultTypeInternal;
extern RtmpEmptyObjectDefaultTypeInternal _RtmpEmptyObject_default_instance_;
class RtmpInfo;
struct RtmpInfoDefaultTypeInternal;
extern RtmpInfoDefaultTypeInternal _RtmpInfo_default_instance_;
class RtmpPlay2Options;
struct RtmpPlay2OptionsDefaultTypeInternal;
extern RtmpPlay2OptionsDefaultTypeInternal _RtmpPlay2Options_default_instance_;
}  // namespace brpc
PROTOBUF_NAMESPACE_OPEN
template<> ::brpc::RtmpConnectRequest* Arena::CreateMaybeMessage<::brpc::RtmpConnectRequest>(Arena*);
template<> ::brpc::RtmpConnectResponse* Arena::CreateMaybeMessage<::brpc::RtmpConnectResponse>(Arena*);
template<> ::brpc::RtmpEmptyObject* Arena::CreateMaybeMessage<::brpc::RtmpEmptyObject>(Arena*);
template<> ::brpc::RtmpInfo* Arena::CreateMaybeMessage<::brpc::RtmpInfo>(Arena*);
template<> ::brpc::RtmpPlay2Options* Arena::CreateMaybeMessage<::brpc::RtmpPlay2Options>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace brpc {

// ===================================================================

class RtmpConnectRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:brpc.RtmpConnectRequest) */ {
 public:
  inline RtmpConnectRequest() : RtmpConnectRequest(nullptr) {}
  ~RtmpConnectRequest() override;
  explicit PROTOBUF_CONSTEXPR RtmpConnectRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RtmpConnectRequest(const RtmpConnectRequest& from);
  RtmpConnectRequest(RtmpConnectRequest&& from) noexcept
    : RtmpConnectRequest() {
    *this = ::std::move(from);
  }

  inline RtmpConnectRequest& operator=(const RtmpConnectRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RtmpConnectRequest& operator=(RtmpConnectRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RtmpConnectRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RtmpConnectRequest* internal_default_instance() {
    return reinterpret_cast<const RtmpConnectRequest*>(
               &_RtmpConnectRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(RtmpConnectRequest& a, RtmpConnectRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RtmpConnectRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RtmpConnectRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RtmpConnectRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RtmpConnectRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RtmpConnectRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RtmpConnectRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RtmpConnectRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "brpc.RtmpConnectRequest";
  }
  protected:
  explicit RtmpConnectRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAppFieldNumber = 1,
    kFlashVerFieldNumber = 2,
    kSwfUrlFieldNumber = 3,
    kTcUrlFieldNumber = 4,
    kPageUrlFieldNumber = 10,
    kCapabilitiesFieldNumber = 6,
    kAudioCodecsFieldNumber = 7,
    kVideoCodecsFieldNumber = 8,
    kVideoFunctionFieldNumber = 9,
    kObjectEncodingFieldNumber = 11,
    kFpadFieldNumber = 5,
    kStreamMultiplexingFieldNumber = 12,
  };
  // optional string app = 1;
  bool has_app() const;
  private:
  bool _internal_has_app() const;
  public:
  void clear_app();
  const std::string& app() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_app(ArgT0&& arg0, ArgT... args);
  std::string* mutable_app();
  PROTOBUF_NODISCARD std::string* release_app();
  void set_allocated_app(std::string* app);
  private:
  const std::string& _internal_app() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_app(const std::string& value);
  std::string* _internal_mutable_app();
  public:

  // optional string flashVer = 2;
  bool has_flashver() const;
  private:
  bool _internal_has_flashver() const;
  public:
  void clear_flashver();
  const std::string& flashver() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_flashver(ArgT0&& arg0, ArgT... args);
  std::string* mutable_flashver();
  PROTOBUF_NODISCARD std::string* release_flashver();
  void set_allocated_flashver(std::string* flashver);
  private:
  const std::string& _internal_flashver() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_flashver(const std::string& value);
  std::string* _internal_mutable_flashver();
  public:

  // optional string swfUrl = 3;
  bool has_swfurl() const;
  private:
  bool _internal_has_swfurl() const;
  public:
  void clear_swfurl();
  const std::string& swfurl() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_swfurl(ArgT0&& arg0, ArgT... args);
  std::string* mutable_swfurl();
  PROTOBUF_NODISCARD std::string* release_swfurl();
  void set_allocated_swfurl(std::string* swfurl);
  private:
  const std::string& _internal_swfurl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_swfurl(const std::string& value);
  std::string* _internal_mutable_swfurl();
  public:

  // optional string tcUrl = 4;
  bool has_tcurl() const;
  private:
  bool _internal_has_tcurl() const;
  public:
  void clear_tcurl();
  const std::string& tcurl() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tcurl(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tcurl();
  PROTOBUF_NODISCARD std::string* release_tcurl();
  void set_allocated_tcurl(std::string* tcurl);
  private:
  const std::string& _internal_tcurl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tcurl(const std::string& value);
  std::string* _internal_mutable_tcurl();
  public:

  // optional string pageUrl = 10;
  bool has_pageurl() const;
  private:
  bool _internal_has_pageurl() const;
  public:
  void clear_pageurl();
  const std::string& pageurl() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pageurl(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pageurl();
  PROTOBUF_NODISCARD std::string* release_pageurl();
  void set_allocated_pageurl(std::string* pageurl);
  private:
  const std::string& _internal_pageurl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pageurl(const std::string& value);
  std::string* _internal_mutable_pageurl();
  public:

  // optional double capabilities = 6;
  bool has_capabilities() const;
  private:
  bool _internal_has_capabilities() const;
  public:
  void clear_capabilities();
  double capabilities() const;
  void set_capabilities(double value);
  private:
  double _internal_capabilities() const;
  void _internal_set_capabilities(double value);
  public:

  // optional double audioCodecs = 7;
  bool has_audiocodecs() const;
  private:
  bool _internal_has_audiocodecs() const;
  public:
  void clear_audiocodecs();
  double audiocodecs() const;
  void set_audiocodecs(double value);
  private:
  double _internal_audiocodecs() const;
  void _internal_set_audiocodecs(double value);
  public:

  // optional double videoCodecs = 8;
  bool has_videocodecs() const;
  private:
  bool _internal_has_videocodecs() const;
  public:
  void clear_videocodecs();
  double videocodecs() const;
  void set_videocodecs(double value);
  private:
  double _internal_videocodecs() const;
  void _internal_set_videocodecs(double value);
  public:

  // optional double videoFunction = 9;
  bool has_videofunction() const;
  private:
  bool _internal_has_videofunction() const;
  public:
  void clear_videofunction();
  double videofunction() const;
  void set_videofunction(double value);
  private:
  double _internal_videofunction() const;
  void _internal_set_videofunction(double value);
  public:

  // optional double objectEncoding = 11;
  bool has_objectencoding() const;
  private:
  bool _internal_has_objectencoding() const;
  public:
  void clear_objectencoding();
  double objectencoding() const;
  void set_objectencoding(double value);
  private:
  double _internal_objectencoding() const;
  void _internal_set_objectencoding(double value);
  public:

  // optional bool fpad = 5;
  bool has_fpad() const;
  private:
  bool _internal_has_fpad() const;
  public:
  void clear_fpad();
  bool fpad() const;
  void set_fpad(bool value);
  private:
  bool _internal_fpad() const;
  void _internal_set_fpad(bool value);
  public:

  // optional bool stream_multiplexing = 12;
  bool has_stream_multiplexing() const;
  private:
  bool _internal_has_stream_multiplexing() const;
  public:
  void clear_stream_multiplexing();
  bool stream_multiplexing() const;
  void set_stream_multiplexing(bool value);
  private:
  bool _internal_stream_multiplexing() const;
  void _internal_set_stream_multiplexing(bool value);
  public:

  // @@protoc_insertion_point(class_scope:brpc.RtmpConnectRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr app_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr flashver_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr swfurl_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tcurl_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pageurl_;
    double capabilities_;
    double audiocodecs_;
    double videocodecs_;
    double videofunction_;
    double objectencoding_;
    bool fpad_;
    bool stream_multiplexing_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_brpc_2frtmp_2eproto;
};
// -------------------------------------------------------------------

class RtmpConnectResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:brpc.RtmpConnectResponse) */ {
 public:
  inline RtmpConnectResponse() : RtmpConnectResponse(nullptr) {}
  ~RtmpConnectResponse() override;
  explicit PROTOBUF_CONSTEXPR RtmpConnectResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RtmpConnectResponse(const RtmpConnectResponse& from);
  RtmpConnectResponse(RtmpConnectResponse&& from) noexcept
    : RtmpConnectResponse() {
    *this = ::std::move(from);
  }

  inline RtmpConnectResponse& operator=(const RtmpConnectResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RtmpConnectResponse& operator=(RtmpConnectResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RtmpConnectResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RtmpConnectResponse* internal_default_instance() {
    return reinterpret_cast<const RtmpConnectResponse*>(
               &_RtmpConnectResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(RtmpConnectResponse& a, RtmpConnectResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RtmpConnectResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RtmpConnectResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RtmpConnectResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RtmpConnectResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RtmpConnectResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RtmpConnectResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RtmpConnectResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "brpc.RtmpConnectResponse";
  }
  protected:
  explicit RtmpConnectResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFmsVerFieldNumber = 1,
    kCapabilitiesFieldNumber = 2,
    kModeFieldNumber = 3,
    kCreateStreamWithPlayOrPublishFieldNumber = 4,
  };
  // optional string fmsVer = 1;
  bool has_fmsver() const;
  private:
  bool _internal_has_fmsver() const;
  public:
  void clear_fmsver();
  const std::string& fmsver() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fmsver(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fmsver();
  PROTOBUF_NODISCARD std::string* release_fmsver();
  void set_allocated_fmsver(std::string* fmsver);
  private:
  const std::string& _internal_fmsver() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fmsver(const std::string& value);
  std::string* _internal_mutable_fmsver();
  public:

  // optional double capabilities = 2;
  bool has_capabilities() const;
  private:
  bool _internal_has_capabilities() const;
  public:
  void clear_capabilities();
  double capabilities() const;
  void set_capabilities(double value);
  private:
  double _internal_capabilities() const;
  void _internal_set_capabilities(double value);
  public:

  // optional double mode = 3;
  bool has_mode() const;
  private:
  bool _internal_has_mode() const;
  public:
  void clear_mode();
  double mode() const;
  void set_mode(double value);
  private:
  double _internal_mode() const;
  void _internal_set_mode(double value);
  public:

  // optional bool create_stream_with_play_or_publish = 4;
  bool has_create_stream_with_play_or_publish() const;
  private:
  bool _internal_has_create_stream_with_play_or_publish() const;
  public:
  void clear_create_stream_with_play_or_publish();
  bool create_stream_with_play_or_publish() const;
  void set_create_stream_with_play_or_publish(bool value);
  private:
  bool _internal_create_stream_with_play_or_publish() const;
  void _internal_set_create_stream_with_play_or_publish(bool value);
  public:

  // @@protoc_insertion_point(class_scope:brpc.RtmpConnectResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fmsver_;
    double capabilities_;
    double mode_;
    bool create_stream_with_play_or_publish_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_brpc_2frtmp_2eproto;
};
// -------------------------------------------------------------------

class RtmpPlay2Options final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:brpc.RtmpPlay2Options) */ {
 public:
  inline RtmpPlay2Options() : RtmpPlay2Options(nullptr) {}
  ~RtmpPlay2Options() override;
  explicit PROTOBUF_CONSTEXPR RtmpPlay2Options(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RtmpPlay2Options(const RtmpPlay2Options& from);
  RtmpPlay2Options(RtmpPlay2Options&& from) noexcept
    : RtmpPlay2Options() {
    *this = ::std::move(from);
  }

  inline RtmpPlay2Options& operator=(const RtmpPlay2Options& from) {
    CopyFrom(from);
    return *this;
  }
  inline RtmpPlay2Options& operator=(RtmpPlay2Options&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RtmpPlay2Options& default_instance() {
    return *internal_default_instance();
  }
  static inline const RtmpPlay2Options* internal_default_instance() {
    return reinterpret_cast<const RtmpPlay2Options*>(
               &_RtmpPlay2Options_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(RtmpPlay2Options& a, RtmpPlay2Options& b) {
    a.Swap(&b);
  }
  inline void Swap(RtmpPlay2Options* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RtmpPlay2Options* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RtmpPlay2Options* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RtmpPlay2Options>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RtmpPlay2Options& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RtmpPlay2Options& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RtmpPlay2Options* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "brpc.RtmpPlay2Options";
  }
  protected:
  explicit RtmpPlay2Options(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOldStreamNameFieldNumber = 3,
    kStreamNameFieldNumber = 5,
    kTransitionFieldNumber = 6,
    kLenFieldNumber = 1,
    kOffsetFieldNumber = 2,
    kStartFieldNumber = 4,
  };
  // optional string oldStreamName = 3;
  bool has_oldstreamname() const;
  private:
  bool _internal_has_oldstreamname() const;
  public:
  void clear_oldstreamname();
  const std::string& oldstreamname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_oldstreamname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_oldstreamname();
  PROTOBUF_NODISCARD std::string* release_oldstreamname();
  void set_allocated_oldstreamname(std::string* oldstreamname);
  private:
  const std::string& _internal_oldstreamname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_oldstreamname(const std::string& value);
  std::string* _internal_mutable_oldstreamname();
  public:

  // optional string streamName = 5;
  bool has_streamname() const;
  private:
  bool _internal_has_streamname() const;
  public:
  void clear_streamname();
  const std::string& streamname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_streamname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_streamname();
  PROTOBUF_NODISCARD std::string* release_streamname();
  void set_allocated_streamname(std::string* streamname);
  private:
  const std::string& _internal_streamname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_streamname(const std::string& value);
  std::string* _internal_mutable_streamname();
  public:

  // optional string transition = 6;
  bool has_transition() const;
  private:
  bool _internal_has_transition() const;
  public:
  void clear_transition();
  const std::string& transition() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_transition(ArgT0&& arg0, ArgT... args);
  std::string* mutable_transition();
  PROTOBUF_NODISCARD std::string* release_transition();
  void set_allocated_transition(std::string* transition);
  private:
  const std::string& _internal_transition() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_transition(const std::string& value);
  std::string* _internal_mutable_transition();
  public:

  // optional double len = 1;
  bool has_len() const;
  private:
  bool _internal_has_len() const;
  public:
  void clear_len();
  double len() const;
  void set_len(double value);
  private:
  double _internal_len() const;
  void _internal_set_len(double value);
  public:

  // optional double offset = 2;
  bool has_offset() const;
  private:
  bool _internal_has_offset() const;
  public:
  void clear_offset();
  double offset() const;
  void set_offset(double value);
  private:
  double _internal_offset() const;
  void _internal_set_offset(double value);
  public:

  // optional double start = 4;
  bool has_start() const;
  private:
  bool _internal_has_start() const;
  public:
  void clear_start();
  double start() const;
  void set_start(double value);
  private:
  double _internal_start() const;
  void _internal_set_start(double value);
  public:

  // @@protoc_insertion_point(class_scope:brpc.RtmpPlay2Options)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr oldstreamname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr streamname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr transition_;
    double len_;
    double offset_;
    double start_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_brpc_2frtmp_2eproto;
};
// -------------------------------------------------------------------

class RtmpInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:brpc.RtmpInfo) */ {
 public:
  inline RtmpInfo() : RtmpInfo(nullptr) {}
  ~RtmpInfo() override;
  explicit PROTOBUF_CONSTEXPR RtmpInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RtmpInfo(const RtmpInfo& from);
  RtmpInfo(RtmpInfo&& from) noexcept
    : RtmpInfo() {
    *this = ::std::move(from);
  }

  inline RtmpInfo& operator=(const RtmpInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline RtmpInfo& operator=(RtmpInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RtmpInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const RtmpInfo* internal_default_instance() {
    return reinterpret_cast<const RtmpInfo*>(
               &_RtmpInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(RtmpInfo& a, RtmpInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(RtmpInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RtmpInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RtmpInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RtmpInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RtmpInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RtmpInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RtmpInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "brpc.RtmpInfo";
  }
  protected:
  explicit RtmpInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCodeFieldNumber = 1,
    kLevelFieldNumber = 2,
    kDescriptionFieldNumber = 3,
    kObjectEncodingFieldNumber = 4,
  };
  // optional string code = 1;
  bool has_code() const;
  private:
  bool _internal_has_code() const;
  public:
  void clear_code();
  const std::string& code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_code();
  PROTOBUF_NODISCARD std::string* release_code();
  void set_allocated_code(std::string* code);
  private:
  const std::string& _internal_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_code(const std::string& value);
  std::string* _internal_mutable_code();
  public:

  // optional string level = 2;
  bool has_level() const;
  private:
  bool _internal_has_level() const;
  public:
  void clear_level();
  const std::string& level() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_level(ArgT0&& arg0, ArgT... args);
  std::string* mutable_level();
  PROTOBUF_NODISCARD std::string* release_level();
  void set_allocated_level(std::string* level);
  private:
  const std::string& _internal_level() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_level(const std::string& value);
  std::string* _internal_mutable_level();
  public:

  // optional string description = 3;
  bool has_description() const;
  private:
  bool _internal_has_description() const;
  public:
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // optional double objectEncoding = 4;
  bool has_objectencoding() const;
  private:
  bool _internal_has_objectencoding() const;
  public:
  void clear_objectencoding();
  double objectencoding() const;
  void set_objectencoding(double value);
  private:
  double _internal_objectencoding() const;
  void _internal_set_objectencoding(double value);
  public:

  // @@protoc_insertion_point(class_scope:brpc.RtmpInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr code_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr level_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    double objectencoding_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_brpc_2frtmp_2eproto;
};
// -------------------------------------------------------------------

class RtmpEmptyObject final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:brpc.RtmpEmptyObject) */ {
 public:
  inline RtmpEmptyObject() : RtmpEmptyObject(nullptr) {}
  explicit PROTOBUF_CONSTEXPR RtmpEmptyObject(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RtmpEmptyObject(const RtmpEmptyObject& from);
  RtmpEmptyObject(RtmpEmptyObject&& from) noexcept
    : RtmpEmptyObject() {
    *this = ::std::move(from);
  }

  inline RtmpEmptyObject& operator=(const RtmpEmptyObject& from) {
    CopyFrom(from);
    return *this;
  }
  inline RtmpEmptyObject& operator=(RtmpEmptyObject&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RtmpEmptyObject& default_instance() {
    return *internal_default_instance();
  }
  static inline const RtmpEmptyObject* internal_default_instance() {
    return reinterpret_cast<const RtmpEmptyObject*>(
               &_RtmpEmptyObject_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(RtmpEmptyObject& a, RtmpEmptyObject& b) {
    a.Swap(&b);
  }
  inline void Swap(RtmpEmptyObject* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RtmpEmptyObject* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RtmpEmptyObject* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RtmpEmptyObject>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const RtmpEmptyObject& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const RtmpEmptyObject& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "brpc.RtmpEmptyObject";
  }
  protected:
  explicit RtmpEmptyObject(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:brpc.RtmpEmptyObject)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_brpc_2frtmp_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RtmpConnectRequest

// optional string app = 1;
inline bool RtmpConnectRequest::_internal_has_app() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RtmpConnectRequest::has_app() const {
  return _internal_has_app();
}
inline void RtmpConnectRequest::clear_app() {
  _impl_.app_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RtmpConnectRequest::app() const {
  // @@protoc_insertion_point(field_get:brpc.RtmpConnectRequest.app)
  return _internal_app();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RtmpConnectRequest::set_app(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.app_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:brpc.RtmpConnectRequest.app)
}
inline std::string* RtmpConnectRequest::mutable_app() {
  std::string* _s = _internal_mutable_app();
  // @@protoc_insertion_point(field_mutable:brpc.RtmpConnectRequest.app)
  return _s;
}
inline const std::string& RtmpConnectRequest::_internal_app() const {
  return _impl_.app_.Get();
}
inline void RtmpConnectRequest::_internal_set_app(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.app_.Set(value, GetArenaForAllocation());
}
inline std::string* RtmpConnectRequest::_internal_mutable_app() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.app_.Mutable(GetArenaForAllocation());
}
inline std::string* RtmpConnectRequest::release_app() {
  // @@protoc_insertion_point(field_release:brpc.RtmpConnectRequest.app)
  if (!_internal_has_app()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.app_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.app_.IsDefault()) {
    _impl_.app_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void RtmpConnectRequest::set_allocated_app(std::string* app) {
  if (app != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.app_.SetAllocated(app, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.app_.IsDefault()) {
    _impl_.app_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:brpc.RtmpConnectRequest.app)
}

// optional string flashVer = 2;
inline bool RtmpConnectRequest::_internal_has_flashver() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RtmpConnectRequest::has_flashver() const {
  return _internal_has_flashver();
}
inline void RtmpConnectRequest::clear_flashver() {
  _impl_.flashver_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& RtmpConnectRequest::flashver() const {
  // @@protoc_insertion_point(field_get:brpc.RtmpConnectRequest.flashVer)
  return _internal_flashver();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RtmpConnectRequest::set_flashver(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.flashver_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:brpc.RtmpConnectRequest.flashVer)
}
inline std::string* RtmpConnectRequest::mutable_flashver() {
  std::string* _s = _internal_mutable_flashver();
  // @@protoc_insertion_point(field_mutable:brpc.RtmpConnectRequest.flashVer)
  return _s;
}
inline const std::string& RtmpConnectRequest::_internal_flashver() const {
  return _impl_.flashver_.Get();
}
inline void RtmpConnectRequest::_internal_set_flashver(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.flashver_.Set(value, GetArenaForAllocation());
}
inline std::string* RtmpConnectRequest::_internal_mutable_flashver() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.flashver_.Mutable(GetArenaForAllocation());
}
inline std::string* RtmpConnectRequest::release_flashver() {
  // @@protoc_insertion_point(field_release:brpc.RtmpConnectRequest.flashVer)
  if (!_internal_has_flashver()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.flashver_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.flashver_.IsDefault()) {
    _impl_.flashver_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void RtmpConnectRequest::set_allocated_flashver(std::string* flashver) {
  if (flashver != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.flashver_.SetAllocated(flashver, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.flashver_.IsDefault()) {
    _impl_.flashver_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:brpc.RtmpConnectRequest.flashVer)
}

// optional string swfUrl = 3;
inline bool RtmpConnectRequest::_internal_has_swfurl() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool RtmpConnectRequest::has_swfurl() const {
  return _internal_has_swfurl();
}
inline void RtmpConnectRequest::clear_swfurl() {
  _impl_.swfurl_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& RtmpConnectRequest::swfurl() const {
  // @@protoc_insertion_point(field_get:brpc.RtmpConnectRequest.swfUrl)
  return _internal_swfurl();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RtmpConnectRequest::set_swfurl(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.swfurl_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:brpc.RtmpConnectRequest.swfUrl)
}
inline std::string* RtmpConnectRequest::mutable_swfurl() {
  std::string* _s = _internal_mutable_swfurl();
  // @@protoc_insertion_point(field_mutable:brpc.RtmpConnectRequest.swfUrl)
  return _s;
}
inline const std::string& RtmpConnectRequest::_internal_swfurl() const {
  return _impl_.swfurl_.Get();
}
inline void RtmpConnectRequest::_internal_set_swfurl(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.swfurl_.Set(value, GetArenaForAllocation());
}
inline std::string* RtmpConnectRequest::_internal_mutable_swfurl() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.swfurl_.Mutable(GetArenaForAllocation());
}
inline std::string* RtmpConnectRequest::release_swfurl() {
  // @@protoc_insertion_point(field_release:brpc.RtmpConnectRequest.swfUrl)
  if (!_internal_has_swfurl()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.swfurl_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.swfurl_.IsDefault()) {
    _impl_.swfurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void RtmpConnectRequest::set_allocated_swfurl(std::string* swfurl) {
  if (swfurl != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.swfurl_.SetAllocated(swfurl, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.swfurl_.IsDefault()) {
    _impl_.swfurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:brpc.RtmpConnectRequest.swfUrl)
}

// optional string tcUrl = 4;
inline bool RtmpConnectRequest::_internal_has_tcurl() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool RtmpConnectRequest::has_tcurl() const {
  return _internal_has_tcurl();
}
inline void RtmpConnectRequest::clear_tcurl() {
  _impl_.tcurl_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& RtmpConnectRequest::tcurl() const {
  // @@protoc_insertion_point(field_get:brpc.RtmpConnectRequest.tcUrl)
  return _internal_tcurl();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RtmpConnectRequest::set_tcurl(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.tcurl_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:brpc.RtmpConnectRequest.tcUrl)
}
inline std::string* RtmpConnectRequest::mutable_tcurl() {
  std::string* _s = _internal_mutable_tcurl();
  // @@protoc_insertion_point(field_mutable:brpc.RtmpConnectRequest.tcUrl)
  return _s;
}
inline const std::string& RtmpConnectRequest::_internal_tcurl() const {
  return _impl_.tcurl_.Get();
}
inline void RtmpConnectRequest::_internal_set_tcurl(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.tcurl_.Set(value, GetArenaForAllocation());
}
inline std::string* RtmpConnectRequest::_internal_mutable_tcurl() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.tcurl_.Mutable(GetArenaForAllocation());
}
inline std::string* RtmpConnectRequest::release_tcurl() {
  // @@protoc_insertion_point(field_release:brpc.RtmpConnectRequest.tcUrl)
  if (!_internal_has_tcurl()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.tcurl_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tcurl_.IsDefault()) {
    _impl_.tcurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void RtmpConnectRequest::set_allocated_tcurl(std::string* tcurl) {
  if (tcurl != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.tcurl_.SetAllocated(tcurl, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tcurl_.IsDefault()) {
    _impl_.tcurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:brpc.RtmpConnectRequest.tcUrl)
}

// optional bool fpad = 5;
inline bool RtmpConnectRequest::_internal_has_fpad() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool RtmpConnectRequest::has_fpad() const {
  return _internal_has_fpad();
}
inline void RtmpConnectRequest::clear_fpad() {
  _impl_.fpad_ = false;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline bool RtmpConnectRequest::_internal_fpad() const {
  return _impl_.fpad_;
}
inline bool RtmpConnectRequest::fpad() const {
  // @@protoc_insertion_point(field_get:brpc.RtmpConnectRequest.fpad)
  return _internal_fpad();
}
inline void RtmpConnectRequest::_internal_set_fpad(bool value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.fpad_ = value;
}
inline void RtmpConnectRequest::set_fpad(bool value) {
  _internal_set_fpad(value);
  // @@protoc_insertion_point(field_set:brpc.RtmpConnectRequest.fpad)
}

// optional double capabilities = 6;
inline bool RtmpConnectRequest::_internal_has_capabilities() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool RtmpConnectRequest::has_capabilities() const {
  return _internal_has_capabilities();
}
inline void RtmpConnectRequest::clear_capabilities() {
  _impl_.capabilities_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline double RtmpConnectRequest::_internal_capabilities() const {
  return _impl_.capabilities_;
}
inline double RtmpConnectRequest::capabilities() const {
  // @@protoc_insertion_point(field_get:brpc.RtmpConnectRequest.capabilities)
  return _internal_capabilities();
}
inline void RtmpConnectRequest::_internal_set_capabilities(double value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.capabilities_ = value;
}
inline void RtmpConnectRequest::set_capabilities(double value) {
  _internal_set_capabilities(value);
  // @@protoc_insertion_point(field_set:brpc.RtmpConnectRequest.capabilities)
}

// optional double audioCodecs = 7;
inline bool RtmpConnectRequest::_internal_has_audiocodecs() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool RtmpConnectRequest::has_audiocodecs() const {
  return _internal_has_audiocodecs();
}
inline void RtmpConnectRequest::clear_audiocodecs() {
  _impl_.audiocodecs_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline double RtmpConnectRequest::_internal_audiocodecs() const {
  return _impl_.audiocodecs_;
}
inline double RtmpConnectRequest::audiocodecs() const {
  // @@protoc_insertion_point(field_get:brpc.RtmpConnectRequest.audioCodecs)
  return _internal_audiocodecs();
}
inline void RtmpConnectRequest::_internal_set_audiocodecs(double value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.audiocodecs_ = value;
}
inline void RtmpConnectRequest::set_audiocodecs(double value) {
  _internal_set_audiocodecs(value);
  // @@protoc_insertion_point(field_set:brpc.RtmpConnectRequest.audioCodecs)
}

// optional double videoCodecs = 8;
inline bool RtmpConnectRequest::_internal_has_videocodecs() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool RtmpConnectRequest::has_videocodecs() const {
  return _internal_has_videocodecs();
}
inline void RtmpConnectRequest::clear_videocodecs() {
  _impl_.videocodecs_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline double RtmpConnectRequest::_internal_videocodecs() const {
  return _impl_.videocodecs_;
}
inline double RtmpConnectRequest::videocodecs() const {
  // @@protoc_insertion_point(field_get:brpc.RtmpConnectRequest.videoCodecs)
  return _internal_videocodecs();
}
inline void RtmpConnectRequest::_internal_set_videocodecs(double value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.videocodecs_ = value;
}
inline void RtmpConnectRequest::set_videocodecs(double value) {
  _internal_set_videocodecs(value);
  // @@protoc_insertion_point(field_set:brpc.RtmpConnectRequest.videoCodecs)
}

// optional double videoFunction = 9;
inline bool RtmpConnectRequest::_internal_has_videofunction() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool RtmpConnectRequest::has_videofunction() const {
  return _internal_has_videofunction();
}
inline void RtmpConnectRequest::clear_videofunction() {
  _impl_.videofunction_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline double RtmpConnectRequest::_internal_videofunction() const {
  return _impl_.videofunction_;
}
inline double RtmpConnectRequest::videofunction() const {
  // @@protoc_insertion_point(field_get:brpc.RtmpConnectRequest.videoFunction)
  return _internal_videofunction();
}
inline void RtmpConnectRequest::_internal_set_videofunction(double value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.videofunction_ = value;
}
inline void RtmpConnectRequest::set_videofunction(double value) {
  _internal_set_videofunction(value);
  // @@protoc_insertion_point(field_set:brpc.RtmpConnectRequest.videoFunction)
}

// optional string pageUrl = 10;
inline bool RtmpConnectRequest::_internal_has_pageurl() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool RtmpConnectRequest::has_pageurl() const {
  return _internal_has_pageurl();
}
inline void RtmpConnectRequest::clear_pageurl() {
  _impl_.pageurl_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& RtmpConnectRequest::pageurl() const {
  // @@protoc_insertion_point(field_get:brpc.RtmpConnectRequest.pageUrl)
  return _internal_pageurl();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RtmpConnectRequest::set_pageurl(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000010u;
 _impl_.pageurl_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:brpc.RtmpConnectRequest.pageUrl)
}
inline std::string* RtmpConnectRequest::mutable_pageurl() {
  std::string* _s = _internal_mutable_pageurl();
  // @@protoc_insertion_point(field_mutable:brpc.RtmpConnectRequest.pageUrl)
  return _s;
}
inline const std::string& RtmpConnectRequest::_internal_pageurl() const {
  return _impl_.pageurl_.Get();
}
inline void RtmpConnectRequest::_internal_set_pageurl(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.pageurl_.Set(value, GetArenaForAllocation());
}
inline std::string* RtmpConnectRequest::_internal_mutable_pageurl() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.pageurl_.Mutable(GetArenaForAllocation());
}
inline std::string* RtmpConnectRequest::release_pageurl() {
  // @@protoc_insertion_point(field_release:brpc.RtmpConnectRequest.pageUrl)
  if (!_internal_has_pageurl()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* p = _impl_.pageurl_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pageurl_.IsDefault()) {
    _impl_.pageurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void RtmpConnectRequest::set_allocated_pageurl(std::string* pageurl) {
  if (pageurl != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.pageurl_.SetAllocated(pageurl, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pageurl_.IsDefault()) {
    _impl_.pageurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:brpc.RtmpConnectRequest.pageUrl)
}

// optional double objectEncoding = 11;
inline bool RtmpConnectRequest::_internal_has_objectencoding() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool RtmpConnectRequest::has_objectencoding() const {
  return _internal_has_objectencoding();
}
inline void RtmpConnectRequest::clear_objectencoding() {
  _impl_.objectencoding_ = 0;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline double RtmpConnectRequest::_internal_objectencoding() const {
  return _impl_.objectencoding_;
}
inline double RtmpConnectRequest::objectencoding() const {
  // @@protoc_insertion_point(field_get:brpc.RtmpConnectRequest.objectEncoding)
  return _internal_objectencoding();
}
inline void RtmpConnectRequest::_internal_set_objectencoding(double value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.objectencoding_ = value;
}
inline void RtmpConnectRequest::set_objectencoding(double value) {
  _internal_set_objectencoding(value);
  // @@protoc_insertion_point(field_set:brpc.RtmpConnectRequest.objectEncoding)
}

// optional bool stream_multiplexing = 12;
inline bool RtmpConnectRequest::_internal_has_stream_multiplexing() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool RtmpConnectRequest::has_stream_multiplexing() const {
  return _internal_has_stream_multiplexing();
}
inline void RtmpConnectRequest::clear_stream_multiplexing() {
  _impl_.stream_multiplexing_ = false;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline bool RtmpConnectRequest::_internal_stream_multiplexing() const {
  return _impl_.stream_multiplexing_;
}
inline bool RtmpConnectRequest::stream_multiplexing() const {
  // @@protoc_insertion_point(field_get:brpc.RtmpConnectRequest.stream_multiplexing)
  return _internal_stream_multiplexing();
}
inline void RtmpConnectRequest::_internal_set_stream_multiplexing(bool value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.stream_multiplexing_ = value;
}
inline void RtmpConnectRequest::set_stream_multiplexing(bool value) {
  _internal_set_stream_multiplexing(value);
  // @@protoc_insertion_point(field_set:brpc.RtmpConnectRequest.stream_multiplexing)
}

// -------------------------------------------------------------------

// RtmpConnectResponse

// optional string fmsVer = 1;
inline bool RtmpConnectResponse::_internal_has_fmsver() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RtmpConnectResponse::has_fmsver() const {
  return _internal_has_fmsver();
}
inline void RtmpConnectResponse::clear_fmsver() {
  _impl_.fmsver_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RtmpConnectResponse::fmsver() const {
  // @@protoc_insertion_point(field_get:brpc.RtmpConnectResponse.fmsVer)
  return _internal_fmsver();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RtmpConnectResponse::set_fmsver(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.fmsver_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:brpc.RtmpConnectResponse.fmsVer)
}
inline std::string* RtmpConnectResponse::mutable_fmsver() {
  std::string* _s = _internal_mutable_fmsver();
  // @@protoc_insertion_point(field_mutable:brpc.RtmpConnectResponse.fmsVer)
  return _s;
}
inline const std::string& RtmpConnectResponse::_internal_fmsver() const {
  return _impl_.fmsver_.Get();
}
inline void RtmpConnectResponse::_internal_set_fmsver(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.fmsver_.Set(value, GetArenaForAllocation());
}
inline std::string* RtmpConnectResponse::_internal_mutable_fmsver() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.fmsver_.Mutable(GetArenaForAllocation());
}
inline std::string* RtmpConnectResponse::release_fmsver() {
  // @@protoc_insertion_point(field_release:brpc.RtmpConnectResponse.fmsVer)
  if (!_internal_has_fmsver()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.fmsver_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fmsver_.IsDefault()) {
    _impl_.fmsver_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void RtmpConnectResponse::set_allocated_fmsver(std::string* fmsver) {
  if (fmsver != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.fmsver_.SetAllocated(fmsver, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fmsver_.IsDefault()) {
    _impl_.fmsver_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:brpc.RtmpConnectResponse.fmsVer)
}

// optional double capabilities = 2;
inline bool RtmpConnectResponse::_internal_has_capabilities() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RtmpConnectResponse::has_capabilities() const {
  return _internal_has_capabilities();
}
inline void RtmpConnectResponse::clear_capabilities() {
  _impl_.capabilities_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double RtmpConnectResponse::_internal_capabilities() const {
  return _impl_.capabilities_;
}
inline double RtmpConnectResponse::capabilities() const {
  // @@protoc_insertion_point(field_get:brpc.RtmpConnectResponse.capabilities)
  return _internal_capabilities();
}
inline void RtmpConnectResponse::_internal_set_capabilities(double value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.capabilities_ = value;
}
inline void RtmpConnectResponse::set_capabilities(double value) {
  _internal_set_capabilities(value);
  // @@protoc_insertion_point(field_set:brpc.RtmpConnectResponse.capabilities)
}

// optional double mode = 3;
inline bool RtmpConnectResponse::_internal_has_mode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool RtmpConnectResponse::has_mode() const {
  return _internal_has_mode();
}
inline void RtmpConnectResponse::clear_mode() {
  _impl_.mode_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double RtmpConnectResponse::_internal_mode() const {
  return _impl_.mode_;
}
inline double RtmpConnectResponse::mode() const {
  // @@protoc_insertion_point(field_get:brpc.RtmpConnectResponse.mode)
  return _internal_mode();
}
inline void RtmpConnectResponse::_internal_set_mode(double value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.mode_ = value;
}
inline void RtmpConnectResponse::set_mode(double value) {
  _internal_set_mode(value);
  // @@protoc_insertion_point(field_set:brpc.RtmpConnectResponse.mode)
}

// optional bool create_stream_with_play_or_publish = 4;
inline bool RtmpConnectResponse::_internal_has_create_stream_with_play_or_publish() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool RtmpConnectResponse::has_create_stream_with_play_or_publish() const {
  return _internal_has_create_stream_with_play_or_publish();
}
inline void RtmpConnectResponse::clear_create_stream_with_play_or_publish() {
  _impl_.create_stream_with_play_or_publish_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool RtmpConnectResponse::_internal_create_stream_with_play_or_publish() const {
  return _impl_.create_stream_with_play_or_publish_;
}
inline bool RtmpConnectResponse::create_stream_with_play_or_publish() const {
  // @@protoc_insertion_point(field_get:brpc.RtmpConnectResponse.create_stream_with_play_or_publish)
  return _internal_create_stream_with_play_or_publish();
}
inline void RtmpConnectResponse::_internal_set_create_stream_with_play_or_publish(bool value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.create_stream_with_play_or_publish_ = value;
}
inline void RtmpConnectResponse::set_create_stream_with_play_or_publish(bool value) {
  _internal_set_create_stream_with_play_or_publish(value);
  // @@protoc_insertion_point(field_set:brpc.RtmpConnectResponse.create_stream_with_play_or_publish)
}

// -------------------------------------------------------------------

// RtmpPlay2Options

// optional double len = 1;
inline bool RtmpPlay2Options::_internal_has_len() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool RtmpPlay2Options::has_len() const {
  return _internal_has_len();
}
inline void RtmpPlay2Options::clear_len() {
  _impl_.len_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline double RtmpPlay2Options::_internal_len() const {
  return _impl_.len_;
}
inline double RtmpPlay2Options::len() const {
  // @@protoc_insertion_point(field_get:brpc.RtmpPlay2Options.len)
  return _internal_len();
}
inline void RtmpPlay2Options::_internal_set_len(double value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.len_ = value;
}
inline void RtmpPlay2Options::set_len(double value) {
  _internal_set_len(value);
  // @@protoc_insertion_point(field_set:brpc.RtmpPlay2Options.len)
}

// optional double offset = 2;
inline bool RtmpPlay2Options::_internal_has_offset() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool RtmpPlay2Options::has_offset() const {
  return _internal_has_offset();
}
inline void RtmpPlay2Options::clear_offset() {
  _impl_.offset_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline double RtmpPlay2Options::_internal_offset() const {
  return _impl_.offset_;
}
inline double RtmpPlay2Options::offset() const {
  // @@protoc_insertion_point(field_get:brpc.RtmpPlay2Options.offset)
  return _internal_offset();
}
inline void RtmpPlay2Options::_internal_set_offset(double value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.offset_ = value;
}
inline void RtmpPlay2Options::set_offset(double value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:brpc.RtmpPlay2Options.offset)
}

// optional string oldStreamName = 3;
inline bool RtmpPlay2Options::_internal_has_oldstreamname() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RtmpPlay2Options::has_oldstreamname() const {
  return _internal_has_oldstreamname();
}
inline void RtmpPlay2Options::clear_oldstreamname() {
  _impl_.oldstreamname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RtmpPlay2Options::oldstreamname() const {
  // @@protoc_insertion_point(field_get:brpc.RtmpPlay2Options.oldStreamName)
  return _internal_oldstreamname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RtmpPlay2Options::set_oldstreamname(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.oldstreamname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:brpc.RtmpPlay2Options.oldStreamName)
}
inline std::string* RtmpPlay2Options::mutable_oldstreamname() {
  std::string* _s = _internal_mutable_oldstreamname();
  // @@protoc_insertion_point(field_mutable:brpc.RtmpPlay2Options.oldStreamName)
  return _s;
}
inline const std::string& RtmpPlay2Options::_internal_oldstreamname() const {
  return _impl_.oldstreamname_.Get();
}
inline void RtmpPlay2Options::_internal_set_oldstreamname(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.oldstreamname_.Set(value, GetArenaForAllocation());
}
inline std::string* RtmpPlay2Options::_internal_mutable_oldstreamname() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.oldstreamname_.Mutable(GetArenaForAllocation());
}
inline std::string* RtmpPlay2Options::release_oldstreamname() {
  // @@protoc_insertion_point(field_release:brpc.RtmpPlay2Options.oldStreamName)
  if (!_internal_has_oldstreamname()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.oldstreamname_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.oldstreamname_.IsDefault()) {
    _impl_.oldstreamname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void RtmpPlay2Options::set_allocated_oldstreamname(std::string* oldstreamname) {
  if (oldstreamname != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.oldstreamname_.SetAllocated(oldstreamname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.oldstreamname_.IsDefault()) {
    _impl_.oldstreamname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:brpc.RtmpPlay2Options.oldStreamName)
}

// optional double start = 4;
inline bool RtmpPlay2Options::_internal_has_start() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool RtmpPlay2Options::has_start() const {
  return _internal_has_start();
}
inline void RtmpPlay2Options::clear_start() {
  _impl_.start_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline double RtmpPlay2Options::_internal_start() const {
  return _impl_.start_;
}
inline double RtmpPlay2Options::start() const {
  // @@protoc_insertion_point(field_get:brpc.RtmpPlay2Options.start)
  return _internal_start();
}
inline void RtmpPlay2Options::_internal_set_start(double value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.start_ = value;
}
inline void RtmpPlay2Options::set_start(double value) {
  _internal_set_start(value);
  // @@protoc_insertion_point(field_set:brpc.RtmpPlay2Options.start)
}

// optional string streamName = 5;
inline bool RtmpPlay2Options::_internal_has_streamname() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RtmpPlay2Options::has_streamname() const {
  return _internal_has_streamname();
}
inline void RtmpPlay2Options::clear_streamname() {
  _impl_.streamname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& RtmpPlay2Options::streamname() const {
  // @@protoc_insertion_point(field_get:brpc.RtmpPlay2Options.streamName)
  return _internal_streamname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RtmpPlay2Options::set_streamname(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.streamname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:brpc.RtmpPlay2Options.streamName)
}
inline std::string* RtmpPlay2Options::mutable_streamname() {
  std::string* _s = _internal_mutable_streamname();
  // @@protoc_insertion_point(field_mutable:brpc.RtmpPlay2Options.streamName)
  return _s;
}
inline const std::string& RtmpPlay2Options::_internal_streamname() const {
  return _impl_.streamname_.Get();
}
inline void RtmpPlay2Options::_internal_set_streamname(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.streamname_.Set(value, GetArenaForAllocation());
}
inline std::string* RtmpPlay2Options::_internal_mutable_streamname() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.streamname_.Mutable(GetArenaForAllocation());
}
inline std::string* RtmpPlay2Options::release_streamname() {
  // @@protoc_insertion_point(field_release:brpc.RtmpPlay2Options.streamName)
  if (!_internal_has_streamname()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.streamname_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.streamname_.IsDefault()) {
    _impl_.streamname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void RtmpPlay2Options::set_allocated_streamname(std::string* streamname) {
  if (streamname != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.streamname_.SetAllocated(streamname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.streamname_.IsDefault()) {
    _impl_.streamname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:brpc.RtmpPlay2Options.streamName)
}

// optional string transition = 6;
inline bool RtmpPlay2Options::_internal_has_transition() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool RtmpPlay2Options::has_transition() const {
  return _internal_has_transition();
}
inline void RtmpPlay2Options::clear_transition() {
  _impl_.transition_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& RtmpPlay2Options::transition() const {
  // @@protoc_insertion_point(field_get:brpc.RtmpPlay2Options.transition)
  return _internal_transition();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RtmpPlay2Options::set_transition(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.transition_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:brpc.RtmpPlay2Options.transition)
}
inline std::string* RtmpPlay2Options::mutable_transition() {
  std::string* _s = _internal_mutable_transition();
  // @@protoc_insertion_point(field_mutable:brpc.RtmpPlay2Options.transition)
  return _s;
}
inline const std::string& RtmpPlay2Options::_internal_transition() const {
  return _impl_.transition_.Get();
}
inline void RtmpPlay2Options::_internal_set_transition(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.transition_.Set(value, GetArenaForAllocation());
}
inline std::string* RtmpPlay2Options::_internal_mutable_transition() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.transition_.Mutable(GetArenaForAllocation());
}
inline std::string* RtmpPlay2Options::release_transition() {
  // @@protoc_insertion_point(field_release:brpc.RtmpPlay2Options.transition)
  if (!_internal_has_transition()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.transition_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.transition_.IsDefault()) {
    _impl_.transition_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void RtmpPlay2Options::set_allocated_transition(std::string* transition) {
  if (transition != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.transition_.SetAllocated(transition, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.transition_.IsDefault()) {
    _impl_.transition_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:brpc.RtmpPlay2Options.transition)
}

// -------------------------------------------------------------------

// RtmpInfo

// optional string code = 1;
inline bool RtmpInfo::_internal_has_code() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RtmpInfo::has_code() const {
  return _internal_has_code();
}
inline void RtmpInfo::clear_code() {
  _impl_.code_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RtmpInfo::code() const {
  // @@protoc_insertion_point(field_get:brpc.RtmpInfo.code)
  return _internal_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RtmpInfo::set_code(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.code_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:brpc.RtmpInfo.code)
}
inline std::string* RtmpInfo::mutable_code() {
  std::string* _s = _internal_mutable_code();
  // @@protoc_insertion_point(field_mutable:brpc.RtmpInfo.code)
  return _s;
}
inline const std::string& RtmpInfo::_internal_code() const {
  return _impl_.code_.Get();
}
inline void RtmpInfo::_internal_set_code(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.code_.Set(value, GetArenaForAllocation());
}
inline std::string* RtmpInfo::_internal_mutable_code() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.code_.Mutable(GetArenaForAllocation());
}
inline std::string* RtmpInfo::release_code() {
  // @@protoc_insertion_point(field_release:brpc.RtmpInfo.code)
  if (!_internal_has_code()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.code_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.code_.IsDefault()) {
    _impl_.code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void RtmpInfo::set_allocated_code(std::string* code) {
  if (code != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.code_.SetAllocated(code, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.code_.IsDefault()) {
    _impl_.code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:brpc.RtmpInfo.code)
}

// optional string level = 2;
inline bool RtmpInfo::_internal_has_level() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RtmpInfo::has_level() const {
  return _internal_has_level();
}
inline void RtmpInfo::clear_level() {
  _impl_.level_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& RtmpInfo::level() const {
  // @@protoc_insertion_point(field_get:brpc.RtmpInfo.level)
  return _internal_level();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RtmpInfo::set_level(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.level_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:brpc.RtmpInfo.level)
}
inline std::string* RtmpInfo::mutable_level() {
  std::string* _s = _internal_mutable_level();
  // @@protoc_insertion_point(field_mutable:brpc.RtmpInfo.level)
  return _s;
}
inline const std::string& RtmpInfo::_internal_level() const {
  return _impl_.level_.Get();
}
inline void RtmpInfo::_internal_set_level(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.level_.Set(value, GetArenaForAllocation());
}
inline std::string* RtmpInfo::_internal_mutable_level() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.level_.Mutable(GetArenaForAllocation());
}
inline std::string* RtmpInfo::release_level() {
  // @@protoc_insertion_point(field_release:brpc.RtmpInfo.level)
  if (!_internal_has_level()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.level_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.level_.IsDefault()) {
    _impl_.level_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void RtmpInfo::set_allocated_level(std::string* level) {
  if (level != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.level_.SetAllocated(level, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.level_.IsDefault()) {
    _impl_.level_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:brpc.RtmpInfo.level)
}

// optional string description = 3;
inline bool RtmpInfo::_internal_has_description() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool RtmpInfo::has_description() const {
  return _internal_has_description();
}
inline void RtmpInfo::clear_description() {
  _impl_.description_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& RtmpInfo::description() const {
  // @@protoc_insertion_point(field_get:brpc.RtmpInfo.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RtmpInfo::set_description(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:brpc.RtmpInfo.description)
}
inline std::string* RtmpInfo::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:brpc.RtmpInfo.description)
  return _s;
}
inline const std::string& RtmpInfo::_internal_description() const {
  return _impl_.description_.Get();
}
inline void RtmpInfo::_internal_set_description(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* RtmpInfo::_internal_mutable_description() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* RtmpInfo::release_description() {
  // @@protoc_insertion_point(field_release:brpc.RtmpInfo.description)
  if (!_internal_has_description()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.description_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void RtmpInfo::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:brpc.RtmpInfo.description)
}

// optional double objectEncoding = 4;
inline bool RtmpInfo::_internal_has_objectencoding() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool RtmpInfo::has_objectencoding() const {
  return _internal_has_objectencoding();
}
inline void RtmpInfo::clear_objectencoding() {
  _impl_.objectencoding_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline double RtmpInfo::_internal_objectencoding() const {
  return _impl_.objectencoding_;
}
inline double RtmpInfo::objectencoding() const {
  // @@protoc_insertion_point(field_get:brpc.RtmpInfo.objectEncoding)
  return _internal_objectencoding();
}
inline void RtmpInfo::_internal_set_objectencoding(double value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.objectencoding_ = value;
}
inline void RtmpInfo::set_objectencoding(double value) {
  _internal_set_objectencoding(value);
  // @@protoc_insertion_point(field_set:brpc.RtmpInfo.objectEncoding)
}

// -------------------------------------------------------------------

// RtmpEmptyObject

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace brpc

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_brpc_2frtmp_2eproto
