// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: brpc/rtmp.proto

#include "brpc/rtmp.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace brpc {
PROTOBUF_CONSTEXPR RtmpConnectRequest::RtmpConnectRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.app_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.flashver_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.swfurl_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.tcurl_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.pageurl_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.capabilities_)*/0
  , /*decltype(_impl_.audiocodecs_)*/0
  , /*decltype(_impl_.videocodecs_)*/0
  , /*decltype(_impl_.videofunction_)*/0
  , /*decltype(_impl_.objectencoding_)*/0
  , /*decltype(_impl_.fpad_)*/false
  , /*decltype(_impl_.stream_multiplexing_)*/false} {}
struct RtmpConnectRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RtmpConnectRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RtmpConnectRequestDefaultTypeInternal() {}
  union {
    RtmpConnectRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RtmpConnectRequestDefaultTypeInternal _RtmpConnectRequest_default_instance_;
PROTOBUF_CONSTEXPR RtmpConnectResponse::RtmpConnectResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.fmsver_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.capabilities_)*/0
  , /*decltype(_impl_.mode_)*/0
  , /*decltype(_impl_.create_stream_with_play_or_publish_)*/false} {}
struct RtmpConnectResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RtmpConnectResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RtmpConnectResponseDefaultTypeInternal() {}
  union {
    RtmpConnectResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RtmpConnectResponseDefaultTypeInternal _RtmpConnectResponse_default_instance_;
PROTOBUF_CONSTEXPR RtmpPlay2Options::RtmpPlay2Options(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.oldstreamname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.streamname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.transition_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.len_)*/0
  , /*decltype(_impl_.offset_)*/0
  , /*decltype(_impl_.start_)*/0} {}
struct RtmpPlay2OptionsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RtmpPlay2OptionsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RtmpPlay2OptionsDefaultTypeInternal() {}
  union {
    RtmpPlay2Options _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RtmpPlay2OptionsDefaultTypeInternal _RtmpPlay2Options_default_instance_;
PROTOBUF_CONSTEXPR RtmpInfo::RtmpInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.code_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.level_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.description_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.objectencoding_)*/0} {}
struct RtmpInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RtmpInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RtmpInfoDefaultTypeInternal() {}
  union {
    RtmpInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RtmpInfoDefaultTypeInternal _RtmpInfo_default_instance_;
PROTOBUF_CONSTEXPR RtmpEmptyObject::RtmpEmptyObject(
    ::_pbi::ConstantInitialized) {}
struct RtmpEmptyObjectDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RtmpEmptyObjectDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RtmpEmptyObjectDefaultTypeInternal() {}
  union {
    RtmpEmptyObject _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RtmpEmptyObjectDefaultTypeInternal _RtmpEmptyObject_default_instance_;
}  // namespace brpc
static ::_pb::Metadata file_level_metadata_brpc_2frtmp_2eproto[5];
static constexpr ::_pb::EnumDescriptor const** file_level_enum_descriptors_brpc_2frtmp_2eproto = nullptr;
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_brpc_2frtmp_2eproto = nullptr;

const uint32_t TableStruct_brpc_2frtmp_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::brpc::RtmpConnectRequest, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::brpc::RtmpConnectRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::brpc::RtmpConnectRequest, _impl_.app_),
  PROTOBUF_FIELD_OFFSET(::brpc::RtmpConnectRequest, _impl_.flashver_),
  PROTOBUF_FIELD_OFFSET(::brpc::RtmpConnectRequest, _impl_.swfurl_),
  PROTOBUF_FIELD_OFFSET(::brpc::RtmpConnectRequest, _impl_.tcurl_),
  PROTOBUF_FIELD_OFFSET(::brpc::RtmpConnectRequest, _impl_.fpad_),
  PROTOBUF_FIELD_OFFSET(::brpc::RtmpConnectRequest, _impl_.capabilities_),
  PROTOBUF_FIELD_OFFSET(::brpc::RtmpConnectRequest, _impl_.audiocodecs_),
  PROTOBUF_FIELD_OFFSET(::brpc::RtmpConnectRequest, _impl_.videocodecs_),
  PROTOBUF_FIELD_OFFSET(::brpc::RtmpConnectRequest, _impl_.videofunction_),
  PROTOBUF_FIELD_OFFSET(::brpc::RtmpConnectRequest, _impl_.pageurl_),
  PROTOBUF_FIELD_OFFSET(::brpc::RtmpConnectRequest, _impl_.objectencoding_),
  PROTOBUF_FIELD_OFFSET(::brpc::RtmpConnectRequest, _impl_.stream_multiplexing_),
  0,
  1,
  2,
  3,
  10,
  5,
  6,
  7,
  8,
  4,
  9,
  11,
  PROTOBUF_FIELD_OFFSET(::brpc::RtmpConnectResponse, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::brpc::RtmpConnectResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::brpc::RtmpConnectResponse, _impl_.fmsver_),
  PROTOBUF_FIELD_OFFSET(::brpc::RtmpConnectResponse, _impl_.capabilities_),
  PROTOBUF_FIELD_OFFSET(::brpc::RtmpConnectResponse, _impl_.mode_),
  PROTOBUF_FIELD_OFFSET(::brpc::RtmpConnectResponse, _impl_.create_stream_with_play_or_publish_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::brpc::RtmpPlay2Options, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::brpc::RtmpPlay2Options, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::brpc::RtmpPlay2Options, _impl_.len_),
  PROTOBUF_FIELD_OFFSET(::brpc::RtmpPlay2Options, _impl_.offset_),
  PROTOBUF_FIELD_OFFSET(::brpc::RtmpPlay2Options, _impl_.oldstreamname_),
  PROTOBUF_FIELD_OFFSET(::brpc::RtmpPlay2Options, _impl_.start_),
  PROTOBUF_FIELD_OFFSET(::brpc::RtmpPlay2Options, _impl_.streamname_),
  PROTOBUF_FIELD_OFFSET(::brpc::RtmpPlay2Options, _impl_.transition_),
  3,
  4,
  0,
  5,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::brpc::RtmpInfo, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::brpc::RtmpInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::brpc::RtmpInfo, _impl_.code_),
  PROTOBUF_FIELD_OFFSET(::brpc::RtmpInfo, _impl_.level_),
  PROTOBUF_FIELD_OFFSET(::brpc::RtmpInfo, _impl_.description_),
  PROTOBUF_FIELD_OFFSET(::brpc::RtmpInfo, _impl_.objectencoding_),
  0,
  1,
  2,
  3,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::brpc::RtmpEmptyObject, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 18, -1, sizeof(::brpc::RtmpConnectRequest)},
  { 30, 40, -1, sizeof(::brpc::RtmpConnectResponse)},
  { 44, 56, -1, sizeof(::brpc::RtmpPlay2Options)},
  { 62, 72, -1, sizeof(::brpc::RtmpInfo)},
  { 76, -1, -1, sizeof(::brpc::RtmpEmptyObject)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::brpc::_RtmpConnectRequest_default_instance_._instance,
  &::brpc::_RtmpConnectResponse_default_instance_._instance,
  &::brpc::_RtmpPlay2Options_default_instance_._instance,
  &::brpc::_RtmpInfo_default_instance_._instance,
  &::brpc::_RtmpEmptyObject_default_instance_._instance,
};

const char descriptor_table_protodef_brpc_2frtmp_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\017brpc/rtmp.proto\022\004brpc\"\375\001\n\022RtmpConnectR"
  "equest\022\013\n\003app\030\001 \001(\t\022\020\n\010flashVer\030\002 \001(\t\022\016\n"
  "\006swfUrl\030\003 \001(\t\022\r\n\005tcUrl\030\004 \001(\t\022\014\n\004fpad\030\005 \001"
  "(\010\022\024\n\014capabilities\030\006 \001(\001\022\023\n\013audioCodecs\030"
  "\007 \001(\001\022\023\n\013videoCodecs\030\010 \001(\001\022\025\n\rvideoFunct"
  "ion\030\t \001(\001\022\017\n\007pageUrl\030\n \001(\t\022\026\n\016objectEnco"
  "ding\030\013 \001(\001\022\033\n\023stream_multiplexing\030\014 \001(\010\""
  "u\n\023RtmpConnectResponse\022\016\n\006fmsVer\030\001 \001(\t\022\024"
  "\n\014capabilities\030\002 \001(\001\022\014\n\004mode\030\003 \001(\001\022*\n\"cr"
  "eate_stream_with_play_or_publish\030\004 \001(\010\"}"
  "\n\020RtmpPlay2Options\022\013\n\003len\030\001 \001(\001\022\016\n\006offse"
  "t\030\002 \001(\001\022\025\n\roldStreamName\030\003 \001(\t\022\r\n\005start\030"
  "\004 \001(\001\022\022\n\nstreamName\030\005 \001(\t\022\022\n\ntransition\030"
  "\006 \001(\t\"T\n\010RtmpInfo\022\014\n\004code\030\001 \001(\t\022\r\n\005level"
  "\030\002 \001(\t\022\023\n\013description\030\003 \001(\t\022\026\n\016objectEnc"
  "oding\030\004 \001(\001\"\021\n\017RtmpEmptyObject"
  ;
static ::_pbi::once_flag descriptor_table_brpc_2frtmp_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_brpc_2frtmp_2eproto = {
    false, false, 630, descriptor_table_protodef_brpc_2frtmp_2eproto,
    "brpc/rtmp.proto",
    &descriptor_table_brpc_2frtmp_2eproto_once, nullptr, 0, 5,
    schemas, file_default_instances, TableStruct_brpc_2frtmp_2eproto::offsets,
    file_level_metadata_brpc_2frtmp_2eproto, file_level_enum_descriptors_brpc_2frtmp_2eproto,
    file_level_service_descriptors_brpc_2frtmp_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_brpc_2frtmp_2eproto_getter() {
  return &descriptor_table_brpc_2frtmp_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_brpc_2frtmp_2eproto(&descriptor_table_brpc_2frtmp_2eproto);
namespace brpc {

// ===================================================================

class RtmpConnectRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<RtmpConnectRequest>()._impl_._has_bits_);
  static void set_has_app(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_flashver(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_swfurl(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_tcurl(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_fpad(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_capabilities(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_audiocodecs(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_videocodecs(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_videofunction(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_pageurl(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_objectencoding(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_stream_multiplexing(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
};

RtmpConnectRequest::RtmpConnectRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:brpc.RtmpConnectRequest)
}
RtmpConnectRequest::RtmpConnectRequest(const RtmpConnectRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.app_){}
    , decltype(_impl_.flashver_){}
    , decltype(_impl_.swfurl_){}
    , decltype(_impl_.tcurl_){}
    , decltype(_impl_.pageurl_){}
    , decltype(_impl_.capabilities_){}
    , decltype(_impl_.audiocodecs_){}
    , decltype(_impl_.videocodecs_){}
    , decltype(_impl_.videofunction_){}
    , decltype(_impl_.objectencoding_){}
    , decltype(_impl_.fpad_){}
    , decltype(_impl_.stream_multiplexing_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.app_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.app_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_app()) {
    _impl_.app_.Set(from._internal_app(), 
      GetArenaForAllocation());
  }
  _impl_.flashver_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.flashver_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_flashver()) {
    _impl_.flashver_.Set(from._internal_flashver(), 
      GetArenaForAllocation());
  }
  _impl_.swfurl_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.swfurl_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_swfurl()) {
    _impl_.swfurl_.Set(from._internal_swfurl(), 
      GetArenaForAllocation());
  }
  _impl_.tcurl_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tcurl_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_tcurl()) {
    _impl_.tcurl_.Set(from._internal_tcurl(), 
      GetArenaForAllocation());
  }
  _impl_.pageurl_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.pageurl_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_pageurl()) {
    _impl_.pageurl_.Set(from._internal_pageurl(), 
      GetArenaForAllocation());
  }
  ::memcpy(&_impl_.capabilities_, &from._impl_.capabilities_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.stream_multiplexing_) -
    reinterpret_cast<char*>(&_impl_.capabilities_)) + sizeof(_impl_.stream_multiplexing_));
  // @@protoc_insertion_point(copy_constructor:brpc.RtmpConnectRequest)
}

inline void RtmpConnectRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.app_){}
    , decltype(_impl_.flashver_){}
    , decltype(_impl_.swfurl_){}
    , decltype(_impl_.tcurl_){}
    , decltype(_impl_.pageurl_){}
    , decltype(_impl_.capabilities_){0}
    , decltype(_impl_.audiocodecs_){0}
    , decltype(_impl_.videocodecs_){0}
    , decltype(_impl_.videofunction_){0}
    , decltype(_impl_.objectencoding_){0}
    , decltype(_impl_.fpad_){false}
    , decltype(_impl_.stream_multiplexing_){false}
  };
  _impl_.app_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.app_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.flashver_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.flashver_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.swfurl_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.swfurl_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.tcurl_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tcurl_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.pageurl_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.pageurl_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

RtmpConnectRequest::~RtmpConnectRequest() {
  // @@protoc_insertion_point(destructor:brpc.RtmpConnectRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RtmpConnectRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.app_.Destroy();
  _impl_.flashver_.Destroy();
  _impl_.swfurl_.Destroy();
  _impl_.tcurl_.Destroy();
  _impl_.pageurl_.Destroy();
}

void RtmpConnectRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RtmpConnectRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:brpc.RtmpConnectRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.app_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.flashver_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.swfurl_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.tcurl_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.pageurl_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000e0u) {
    ::memset(&_impl_.capabilities_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.videocodecs_) -
        reinterpret_cast<char*>(&_impl_.capabilities_)) + sizeof(_impl_.videocodecs_));
  }
  if (cached_has_bits & 0x00000f00u) {
    ::memset(&_impl_.videofunction_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.stream_multiplexing_) -
        reinterpret_cast<char*>(&_impl_.videofunction_)) + sizeof(_impl_.stream_multiplexing_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RtmpConnectRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string app = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_app();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "brpc.RtmpConnectRequest.app");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string flashVer = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_flashver();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "brpc.RtmpConnectRequest.flashVer");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string swfUrl = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_swfurl();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "brpc.RtmpConnectRequest.swfUrl");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string tcUrl = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_tcurl();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "brpc.RtmpConnectRequest.tcUrl");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional bool fpad = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_fpad(&has_bits);
          _impl_.fpad_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double capabilities = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 49)) {
          _Internal::set_has_capabilities(&has_bits);
          _impl_.capabilities_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double audioCodecs = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 57)) {
          _Internal::set_has_audiocodecs(&has_bits);
          _impl_.audiocodecs_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double videoCodecs = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 65)) {
          _Internal::set_has_videocodecs(&has_bits);
          _impl_.videocodecs_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double videoFunction = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 73)) {
          _Internal::set_has_videofunction(&has_bits);
          _impl_.videofunction_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional string pageUrl = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          auto str = _internal_mutable_pageurl();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "brpc.RtmpConnectRequest.pageUrl");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional double objectEncoding = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 89)) {
          _Internal::set_has_objectencoding(&has_bits);
          _impl_.objectencoding_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional bool stream_multiplexing = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_stream_multiplexing(&has_bits);
          _impl_.stream_multiplexing_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RtmpConnectRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:brpc.RtmpConnectRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string app = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_app().data(), static_cast<int>(this->_internal_app().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "brpc.RtmpConnectRequest.app");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_app(), target);
  }

  // optional string flashVer = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_flashver().data(), static_cast<int>(this->_internal_flashver().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "brpc.RtmpConnectRequest.flashVer");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_flashver(), target);
  }

  // optional string swfUrl = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_swfurl().data(), static_cast<int>(this->_internal_swfurl().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "brpc.RtmpConnectRequest.swfUrl");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_swfurl(), target);
  }

  // optional string tcUrl = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_tcurl().data(), static_cast<int>(this->_internal_tcurl().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "brpc.RtmpConnectRequest.tcUrl");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_tcurl(), target);
  }

  // optional bool fpad = 5;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_fpad(), target);
  }

  // optional double capabilities = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(6, this->_internal_capabilities(), target);
  }

  // optional double audioCodecs = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(7, this->_internal_audiocodecs(), target);
  }

  // optional double videoCodecs = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(8, this->_internal_videocodecs(), target);
  }

  // optional double videoFunction = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(9, this->_internal_videofunction(), target);
  }

  // optional string pageUrl = 10;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_pageurl().data(), static_cast<int>(this->_internal_pageurl().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "brpc.RtmpConnectRequest.pageUrl");
    target = stream->WriteStringMaybeAliased(
        10, this->_internal_pageurl(), target);
  }

  // optional double objectEncoding = 11;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(11, this->_internal_objectencoding(), target);
  }

  // optional bool stream_multiplexing = 12;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(12, this->_internal_stream_multiplexing(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:brpc.RtmpConnectRequest)
  return target;
}

size_t RtmpConnectRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:brpc.RtmpConnectRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string app = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_app());
    }

    // optional string flashVer = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_flashver());
    }

    // optional string swfUrl = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_swfurl());
    }

    // optional string tcUrl = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_tcurl());
    }

    // optional string pageUrl = 10;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_pageurl());
    }

    // optional double capabilities = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 8;
    }

    // optional double audioCodecs = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 8;
    }

    // optional double videoCodecs = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 8;
    }

  }
  if (cached_has_bits & 0x00000f00u) {
    // optional double videoFunction = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 8;
    }

    // optional double objectEncoding = 11;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 8;
    }

    // optional bool fpad = 5;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 1;
    }

    // optional bool stream_multiplexing = 12;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RtmpConnectRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RtmpConnectRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RtmpConnectRequest::GetClassData() const { return &_class_data_; }

void RtmpConnectRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<RtmpConnectRequest *>(to)->MergeFrom(
      static_cast<const RtmpConnectRequest &>(from));
}


void RtmpConnectRequest::MergeFrom(const RtmpConnectRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:brpc.RtmpConnectRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_app(from._internal_app());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_flashver(from._internal_flashver());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_swfurl(from._internal_swfurl());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_tcurl(from._internal_tcurl());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_set_pageurl(from._internal_pageurl());
    }
    if (cached_has_bits & 0x00000020u) {
      _impl_.capabilities_ = from._impl_.capabilities_;
    }
    if (cached_has_bits & 0x00000040u) {
      _impl_.audiocodecs_ = from._impl_.audiocodecs_;
    }
    if (cached_has_bits & 0x00000080u) {
      _impl_.videocodecs_ = from._impl_.videocodecs_;
    }
    _impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000f00u) {
    if (cached_has_bits & 0x00000100u) {
      _impl_.videofunction_ = from._impl_.videofunction_;
    }
    if (cached_has_bits & 0x00000200u) {
      _impl_.objectencoding_ = from._impl_.objectencoding_;
    }
    if (cached_has_bits & 0x00000400u) {
      _impl_.fpad_ = from._impl_.fpad_;
    }
    if (cached_has_bits & 0x00000800u) {
      _impl_.stream_multiplexing_ = from._impl_.stream_multiplexing_;
    }
    _impl_._has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RtmpConnectRequest::CopyFrom(const RtmpConnectRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:brpc.RtmpConnectRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RtmpConnectRequest::IsInitialized() const {
  return true;
}

void RtmpConnectRequest::InternalSwap(RtmpConnectRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.app_, lhs_arena,
      &other->_impl_.app_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.flashver_, lhs_arena,
      &other->_impl_.flashver_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.swfurl_, lhs_arena,
      &other->_impl_.swfurl_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.tcurl_, lhs_arena,
      &other->_impl_.tcurl_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.pageurl_, lhs_arena,
      &other->_impl_.pageurl_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RtmpConnectRequest, _impl_.stream_multiplexing_)
      + sizeof(RtmpConnectRequest::_impl_.stream_multiplexing_)
      - PROTOBUF_FIELD_OFFSET(RtmpConnectRequest, _impl_.capabilities_)>(
          reinterpret_cast<char*>(&_impl_.capabilities_),
          reinterpret_cast<char*>(&other->_impl_.capabilities_));
}

::PROTOBUF_NAMESPACE_ID::Metadata RtmpConnectRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_brpc_2frtmp_2eproto_getter, &descriptor_table_brpc_2frtmp_2eproto_once,
      file_level_metadata_brpc_2frtmp_2eproto[0]);
}

// ===================================================================

class RtmpConnectResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<RtmpConnectResponse>()._impl_._has_bits_);
  static void set_has_fmsver(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_capabilities(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_create_stream_with_play_or_publish(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

RtmpConnectResponse::RtmpConnectResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:brpc.RtmpConnectResponse)
}
RtmpConnectResponse::RtmpConnectResponse(const RtmpConnectResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.fmsver_){}
    , decltype(_impl_.capabilities_){}
    , decltype(_impl_.mode_){}
    , decltype(_impl_.create_stream_with_play_or_publish_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.fmsver_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.fmsver_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_fmsver()) {
    _impl_.fmsver_.Set(from._internal_fmsver(), 
      GetArenaForAllocation());
  }
  ::memcpy(&_impl_.capabilities_, &from._impl_.capabilities_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.create_stream_with_play_or_publish_) -
    reinterpret_cast<char*>(&_impl_.capabilities_)) + sizeof(_impl_.create_stream_with_play_or_publish_));
  // @@protoc_insertion_point(copy_constructor:brpc.RtmpConnectResponse)
}

inline void RtmpConnectResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.fmsver_){}
    , decltype(_impl_.capabilities_){0}
    , decltype(_impl_.mode_){0}
    , decltype(_impl_.create_stream_with_play_or_publish_){false}
  };
  _impl_.fmsver_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.fmsver_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

RtmpConnectResponse::~RtmpConnectResponse() {
  // @@protoc_insertion_point(destructor:brpc.RtmpConnectResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RtmpConnectResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.fmsver_.Destroy();
}

void RtmpConnectResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RtmpConnectResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:brpc.RtmpConnectResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.fmsver_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.capabilities_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.create_stream_with_play_or_publish_) -
        reinterpret_cast<char*>(&_impl_.capabilities_)) + sizeof(_impl_.create_stream_with_play_or_publish_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RtmpConnectResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string fmsVer = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_fmsver();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "brpc.RtmpConnectResponse.fmsVer");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional double capabilities = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_capabilities(&has_bits);
          _impl_.capabilities_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double mode = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_mode(&has_bits);
          _impl_.mode_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional bool create_stream_with_play_or_publish = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_create_stream_with_play_or_publish(&has_bits);
          _impl_.create_stream_with_play_or_publish_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RtmpConnectResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:brpc.RtmpConnectResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string fmsVer = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_fmsver().data(), static_cast<int>(this->_internal_fmsver().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "brpc.RtmpConnectResponse.fmsVer");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_fmsver(), target);
  }

  // optional double capabilities = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_capabilities(), target);
  }

  // optional double mode = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_mode(), target);
  }

  // optional bool create_stream_with_play_or_publish = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_create_stream_with_play_or_publish(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:brpc.RtmpConnectResponse)
  return target;
}

size_t RtmpConnectResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:brpc.RtmpConnectResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string fmsVer = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_fmsver());
    }

    // optional double capabilities = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional double mode = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

    // optional bool create_stream_with_play_or_publish = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RtmpConnectResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RtmpConnectResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RtmpConnectResponse::GetClassData() const { return &_class_data_; }

void RtmpConnectResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<RtmpConnectResponse *>(to)->MergeFrom(
      static_cast<const RtmpConnectResponse &>(from));
}


void RtmpConnectResponse::MergeFrom(const RtmpConnectResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:brpc.RtmpConnectResponse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_fmsver(from._internal_fmsver());
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.capabilities_ = from._impl_.capabilities_;
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.mode_ = from._impl_.mode_;
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.create_stream_with_play_or_publish_ = from._impl_.create_stream_with_play_or_publish_;
    }
    _impl_._has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RtmpConnectResponse::CopyFrom(const RtmpConnectResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:brpc.RtmpConnectResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RtmpConnectResponse::IsInitialized() const {
  return true;
}

void RtmpConnectResponse::InternalSwap(RtmpConnectResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.fmsver_, lhs_arena,
      &other->_impl_.fmsver_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RtmpConnectResponse, _impl_.create_stream_with_play_or_publish_)
      + sizeof(RtmpConnectResponse::_impl_.create_stream_with_play_or_publish_)
      - PROTOBUF_FIELD_OFFSET(RtmpConnectResponse, _impl_.capabilities_)>(
          reinterpret_cast<char*>(&_impl_.capabilities_),
          reinterpret_cast<char*>(&other->_impl_.capabilities_));
}

::PROTOBUF_NAMESPACE_ID::Metadata RtmpConnectResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_brpc_2frtmp_2eproto_getter, &descriptor_table_brpc_2frtmp_2eproto_once,
      file_level_metadata_brpc_2frtmp_2eproto[1]);
}

// ===================================================================

class RtmpPlay2Options::_Internal {
 public:
  using HasBits = decltype(std::declval<RtmpPlay2Options>()._impl_._has_bits_);
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_offset(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_oldstreamname(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_start(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_streamname(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_transition(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

RtmpPlay2Options::RtmpPlay2Options(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:brpc.RtmpPlay2Options)
}
RtmpPlay2Options::RtmpPlay2Options(const RtmpPlay2Options& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.oldstreamname_){}
    , decltype(_impl_.streamname_){}
    , decltype(_impl_.transition_){}
    , decltype(_impl_.len_){}
    , decltype(_impl_.offset_){}
    , decltype(_impl_.start_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.oldstreamname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.oldstreamname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_oldstreamname()) {
    _impl_.oldstreamname_.Set(from._internal_oldstreamname(), 
      GetArenaForAllocation());
  }
  _impl_.streamname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.streamname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_streamname()) {
    _impl_.streamname_.Set(from._internal_streamname(), 
      GetArenaForAllocation());
  }
  _impl_.transition_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.transition_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_transition()) {
    _impl_.transition_.Set(from._internal_transition(), 
      GetArenaForAllocation());
  }
  ::memcpy(&_impl_.len_, &from._impl_.len_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.start_) -
    reinterpret_cast<char*>(&_impl_.len_)) + sizeof(_impl_.start_));
  // @@protoc_insertion_point(copy_constructor:brpc.RtmpPlay2Options)
}

inline void RtmpPlay2Options::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.oldstreamname_){}
    , decltype(_impl_.streamname_){}
    , decltype(_impl_.transition_){}
    , decltype(_impl_.len_){0}
    , decltype(_impl_.offset_){0}
    , decltype(_impl_.start_){0}
  };
  _impl_.oldstreamname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.oldstreamname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.streamname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.streamname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.transition_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.transition_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

RtmpPlay2Options::~RtmpPlay2Options() {
  // @@protoc_insertion_point(destructor:brpc.RtmpPlay2Options)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RtmpPlay2Options::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.oldstreamname_.Destroy();
  _impl_.streamname_.Destroy();
  _impl_.transition_.Destroy();
}

void RtmpPlay2Options::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RtmpPlay2Options::Clear() {
// @@protoc_insertion_point(message_clear_start:brpc.RtmpPlay2Options)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.oldstreamname_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.streamname_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.transition_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x00000038u) {
    ::memset(&_impl_.len_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.start_) -
        reinterpret_cast<char*>(&_impl_.len_)) + sizeof(_impl_.start_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RtmpPlay2Options::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional double len = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_len(&has_bits);
          _impl_.len_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double offset = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_offset(&has_bits);
          _impl_.offset_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional string oldStreamName = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_oldstreamname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "brpc.RtmpPlay2Options.oldStreamName");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional double start = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _Internal::set_has_start(&has_bits);
          _impl_.start_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional string streamName = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_streamname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "brpc.RtmpPlay2Options.streamName");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string transition = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_transition();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "brpc.RtmpPlay2Options.transition");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RtmpPlay2Options::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:brpc.RtmpPlay2Options)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional double len = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_len(), target);
  }

  // optional double offset = 2;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_offset(), target);
  }

  // optional string oldStreamName = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_oldstreamname().data(), static_cast<int>(this->_internal_oldstreamname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "brpc.RtmpPlay2Options.oldStreamName");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_oldstreamname(), target);
  }

  // optional double start = 4;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_start(), target);
  }

  // optional string streamName = 5;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_streamname().data(), static_cast<int>(this->_internal_streamname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "brpc.RtmpPlay2Options.streamName");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_streamname(), target);
  }

  // optional string transition = 6;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_transition().data(), static_cast<int>(this->_internal_transition().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "brpc.RtmpPlay2Options.transition");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_transition(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:brpc.RtmpPlay2Options)
  return target;
}

size_t RtmpPlay2Options::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:brpc.RtmpPlay2Options)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional string oldStreamName = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_oldstreamname());
    }

    // optional string streamName = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_streamname());
    }

    // optional string transition = 6;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_transition());
    }

    // optional double len = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 8;
    }

    // optional double offset = 2;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 8;
    }

    // optional double start = 4;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RtmpPlay2Options::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RtmpPlay2Options::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RtmpPlay2Options::GetClassData() const { return &_class_data_; }

void RtmpPlay2Options::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<RtmpPlay2Options *>(to)->MergeFrom(
      static_cast<const RtmpPlay2Options &>(from));
}


void RtmpPlay2Options::MergeFrom(const RtmpPlay2Options& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:brpc.RtmpPlay2Options)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_oldstreamname(from._internal_oldstreamname());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_streamname(from._internal_streamname());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_transition(from._internal_transition());
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.len_ = from._impl_.len_;
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.offset_ = from._impl_.offset_;
    }
    if (cached_has_bits & 0x00000020u) {
      _impl_.start_ = from._impl_.start_;
    }
    _impl_._has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RtmpPlay2Options::CopyFrom(const RtmpPlay2Options& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:brpc.RtmpPlay2Options)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RtmpPlay2Options::IsInitialized() const {
  return true;
}

void RtmpPlay2Options::InternalSwap(RtmpPlay2Options* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.oldstreamname_, lhs_arena,
      &other->_impl_.oldstreamname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.streamname_, lhs_arena,
      &other->_impl_.streamname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.transition_, lhs_arena,
      &other->_impl_.transition_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RtmpPlay2Options, _impl_.start_)
      + sizeof(RtmpPlay2Options::_impl_.start_)
      - PROTOBUF_FIELD_OFFSET(RtmpPlay2Options, _impl_.len_)>(
          reinterpret_cast<char*>(&_impl_.len_),
          reinterpret_cast<char*>(&other->_impl_.len_));
}

::PROTOBUF_NAMESPACE_ID::Metadata RtmpPlay2Options::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_brpc_2frtmp_2eproto_getter, &descriptor_table_brpc_2frtmp_2eproto_once,
      file_level_metadata_brpc_2frtmp_2eproto[2]);
}

// ===================================================================

class RtmpInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<RtmpInfo>()._impl_._has_bits_);
  static void set_has_code(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_level(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_description(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_objectencoding(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

RtmpInfo::RtmpInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:brpc.RtmpInfo)
}
RtmpInfo::RtmpInfo(const RtmpInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.code_){}
    , decltype(_impl_.level_){}
    , decltype(_impl_.description_){}
    , decltype(_impl_.objectencoding_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.code_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.code_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_code()) {
    _impl_.code_.Set(from._internal_code(), 
      GetArenaForAllocation());
  }
  _impl_.level_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.level_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_level()) {
    _impl_.level_.Set(from._internal_level(), 
      GetArenaForAllocation());
  }
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_description()) {
    _impl_.description_.Set(from._internal_description(), 
      GetArenaForAllocation());
  }
  _impl_.objectencoding_ = from._impl_.objectencoding_;
  // @@protoc_insertion_point(copy_constructor:brpc.RtmpInfo)
}

inline void RtmpInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.code_){}
    , decltype(_impl_.level_){}
    , decltype(_impl_.description_){}
    , decltype(_impl_.objectencoding_){0}
  };
  _impl_.code_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.code_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.level_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.level_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

RtmpInfo::~RtmpInfo() {
  // @@protoc_insertion_point(destructor:brpc.RtmpInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RtmpInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.code_.Destroy();
  _impl_.level_.Destroy();
  _impl_.description_.Destroy();
}

void RtmpInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RtmpInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:brpc.RtmpInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.code_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.level_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.description_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.objectencoding_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RtmpInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string code = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_code();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "brpc.RtmpInfo.code");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string level = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_level();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "brpc.RtmpInfo.level");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string description = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_description();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "brpc.RtmpInfo.description");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional double objectEncoding = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _Internal::set_has_objectencoding(&has_bits);
          _impl_.objectencoding_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RtmpInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:brpc.RtmpInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string code = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_code().data(), static_cast<int>(this->_internal_code().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "brpc.RtmpInfo.code");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_code(), target);
  }

  // optional string level = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_level().data(), static_cast<int>(this->_internal_level().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "brpc.RtmpInfo.level");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_level(), target);
  }

  // optional string description = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_description().data(), static_cast<int>(this->_internal_description().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "brpc.RtmpInfo.description");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_description(), target);
  }

  // optional double objectEncoding = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_objectencoding(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:brpc.RtmpInfo)
  return target;
}

size_t RtmpInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:brpc.RtmpInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string code = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_code());
    }

    // optional string level = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_level());
    }

    // optional string description = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_description());
    }

    // optional double objectEncoding = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RtmpInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RtmpInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RtmpInfo::GetClassData() const { return &_class_data_; }

void RtmpInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<RtmpInfo *>(to)->MergeFrom(
      static_cast<const RtmpInfo &>(from));
}


void RtmpInfo::MergeFrom(const RtmpInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:brpc.RtmpInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_code(from._internal_code());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_level(from._internal_level());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_description(from._internal_description());
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.objectencoding_ = from._impl_.objectencoding_;
    }
    _impl_._has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RtmpInfo::CopyFrom(const RtmpInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:brpc.RtmpInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RtmpInfo::IsInitialized() const {
  return true;
}

void RtmpInfo::InternalSwap(RtmpInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.code_, lhs_arena,
      &other->_impl_.code_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.level_, lhs_arena,
      &other->_impl_.level_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.description_, lhs_arena,
      &other->_impl_.description_, rhs_arena
  );
  swap(_impl_.objectencoding_, other->_impl_.objectencoding_);
}

::PROTOBUF_NAMESPACE_ID::Metadata RtmpInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_brpc_2frtmp_2eproto_getter, &descriptor_table_brpc_2frtmp_2eproto_once,
      file_level_metadata_brpc_2frtmp_2eproto[3]);
}

// ===================================================================

class RtmpEmptyObject::_Internal {
 public:
};

RtmpEmptyObject::RtmpEmptyObject(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:brpc.RtmpEmptyObject)
}
RtmpEmptyObject::RtmpEmptyObject(const RtmpEmptyObject& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:brpc.RtmpEmptyObject)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RtmpEmptyObject::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RtmpEmptyObject::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata RtmpEmptyObject::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_brpc_2frtmp_2eproto_getter, &descriptor_table_brpc_2frtmp_2eproto_once,
      file_level_metadata_brpc_2frtmp_2eproto[4]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace brpc
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::brpc::RtmpConnectRequest*
Arena::CreateMaybeMessage< ::brpc::RtmpConnectRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::brpc::RtmpConnectRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::brpc::RtmpConnectResponse*
Arena::CreateMaybeMessage< ::brpc::RtmpConnectResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::brpc::RtmpConnectResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::brpc::RtmpPlay2Options*
Arena::CreateMaybeMessage< ::brpc::RtmpPlay2Options >(Arena* arena) {
  return Arena::CreateMessageInternal< ::brpc::RtmpPlay2Options >(arena);
}
template<> PROTOBUF_NOINLINE ::brpc::RtmpInfo*
Arena::CreateMaybeMessage< ::brpc::RtmpInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::brpc::RtmpInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::brpc::RtmpEmptyObject*
Arena::CreateMaybeMessage< ::brpc::RtmpEmptyObject >(Arena* arena) {
  return Arena::CreateMessageInternal< ::brpc::RtmpEmptyObject >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
